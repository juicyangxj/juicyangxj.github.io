<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[与客户交涉有感]]></title>
    <url>%2F2018%2F06%2F29%2F%E4%B8%8E%E5%AE%A2%E6%88%B7%E4%BA%A4%E6%B6%89%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[对于人际交往，我真是满脑子问号了。 为什么？ 对于客户提的要求，我总是很重视，巴不得立刻帮他们解决，然后听到他们说感谢就很开心了。但现实是，客户有问题立刻态度急促地质问，我总是安抚不要着急并找人去解决，解决好了就回复个好的，若我说没法解决，则不回复已经很好了。但是，我的同事却是这样做的，对于客户的问题，可以拖好几天甚至更久，客户找他他也偶尔回复个好的、收到，但是并没有去处理。但客户对他却是一直很有礼貌，不会态度不好甚至会有敬语。我不知道自己到底哪个环节做错了，也不确定自己的热心肠，急性子对于职场上是否不适合。 为什么？ 谈恋爱时，朋友总和我说，谁先认真谁主动谁就输了，我虽听进去了，但对于喜欢的人，因为害怕失去还是会很主动的去表达心意。果然，我和朋友也形成了鲜明的对比，朋友是她男朋友追了好几个月追到的，我很早表明了心意却经常害怕他生气而不敢过分任性，我其实很反感做懂事听话的人，但本性指引我要懂事。有时候忍不住发了脾气，整个人就会感觉很愧疚。 可能每个人的性格不同，但小时候的好脾气在社会中真的不讨好吗？会有很多人故意调侃，遇到社会纠纷，被故意欺负我觉得对方也不容易，不要太小心眼。但有的时候开始自我怀疑，觉得满是委屈，要想在社会做一个厉害的人，是否我该做出些改变？]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人际交往</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2F2018%2F06%2F26%2F%E5%85%B3%E4%BA%8E%E6%88%91%2F</url>
    <content type="text"><![CDATA[90后女孩，目前在江阴，从事前端开发。我所在的这座城市很小，一直挺喜欢的一句话：编剧，重点在藏。你要表达的东西直白说出来就没有美感了，要藏在深处，让人觉得一切是自然而然地表现出来。而这种微妙的感觉每个人所领悟的必然也不一样，这世上的选择并没有正确答案，随心而走，一切都是最好的安排。 我盼望着也等待着。 （更新于2018-6-28）]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Q:你知道如何用line-height使多行文字垂直居中吗？]]></title>
    <url>%2F2018%2F06%2F20%2FQ-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A6%82%E4%BD%95%E7%94%A8line-height%E4%BD%BF%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我们先看运行效果： 知识点 line-height（行高） : 指的是两行文字间基线之间的距离，而实际撑开div高度的不是height，而是line-height。 line box : 每一行称为一条line box，它又是由这一行的许多inline box组成，它的高度可以直接由最大的line-height决定。很多条line box的高度垂直堆叠形成我们见到的div或是p标签之类的父元素高度了。无论line box所占据的高度是多少，其占据的空间都是与文字内容公用水平中垂线的。它的垂直居中的性质可以用来实现文字或图片的垂直居中对齐。 行间距 - 行内框高度 ：行间距是font-size与line-height的差值，被分成两半在内容区的上下行内框高度（替换元素）=内容区宽度行内框高度（非替换元素）=line-height 了解更多替换元素非替换元素的区别点这 一行文字垂直居中根据知识点3，现在可理解只设置行高后，内容区上下方自动填充行间距，使得文字垂直居中。 1&lt;p class="single_line"&gt;这是一行文字这是一行文字这是一行文字&lt;/p&gt; 123.single_line&#123; line-height:150px; border:1px dashed #cccccc; padding-left:5px;font-size:12px;&#125; 多行文字垂直居中要实现高度不固定的文字垂直居中使用padding就好了。对于高度固定的div，里面文字单行或多行显示，字体有大有小怎么办呢？可以借助于line-height。 123456&lt;p class="mulit_line"&gt; &lt;span style="font-size:12px;"&gt;这里是高度为150px的标签内的多行文字，文字大小为12像素。 &lt;br&gt;这里是第二行，用来测试多行的显示效果。 &lt;/span&gt; &lt;i&gt;&amp;nbsp;&lt;/i&gt;&lt;/p&gt; inline-block属性使得外面包了一层line box。根据知识点2以及内联元素默认基线对齐，给span和i都设置为vertical-align:middle即可。实际应用中可将i的width设为0，案例中1px为了帮助理解用。 12345678910111213141516.mulit_line&#123; border:1px dashed #cccccc; padding-left:5px;&#125;.mulit_line span&#123; display:inline-block; vertical-align:middle;&#125;.mulit_line i&#123; width:1px; display:inline-block; vertical-align:middle; font-size:0; background:red; line-height:150px;&#125; 看完整代码点这 更多内容欢迎互相交流一下。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Q:你了解异步编程、进程、单线程、多线程吗？]]></title>
    <url>%2F2018%2F06%2F20%2FQ-%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%8D%95%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[相关定义 Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 同步：一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。 异步：进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 进程：狭义上，就是正在运行的程序的实例。广义上，进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 线程：线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位。指运行中的程序的调度单位。 单线程：单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。单线程就是进程里只有一个线程。 多线程：在单个程序中同时运行多个线程完成不同的工作，称为多线程。 知识点 js是单线程的 JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的，浏览器中很多行为是异步的，会创建事件并放入执行队列中，JavaScript引擎是单线程处理它的任务队列。当异步事件发生时，鼠标点击事件发生、定时器触发事件发生、XMLHttpRequest完成回调触发等，将他们放入执行队列，等待当前代码执行完成。 浏览器不是单线程的 虽然JS运行在浏览器中，是单线程的,但浏览器不是单线程的，例如Web kit引擎，可能有如下线程： JavaScript引擎线程 界面渲染线程 浏览器事件触发线程 HTTP请求线程 当一个异步事件发生的时候，它就进入事件队列。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询事件队列并处理事件。比如，浏览器当前正在忙于处理onclick事件，这时window onSize事件发生了，这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。 为什么JavaScript是单线程的却能让AJAX异步发送和回调请求，为什么setTimeout也看起来像是多线程的？ Ajax请求确实是异步的，这请求是由浏览器新开了一个线程请求，事件回调的时候是放入Event loop单线程事件队列等候处理。当浏览器空闲的时候出队列任务被处理，JavaScript引擎始终是单线程运行回调函数、单线程处理它的任务队列。 setTimeout(func, 0)神奇在哪儿？那就是告诉js引擎，在0ms以后把func放到主事件队列中，等待当前的代码执行完毕再执行，注意：重点是改变了代码流程，把func的执行放到了主事件队列中。这就是它的神奇之处了。它的用处有三个： 让浏览器渲染当前的变化（很多浏览器UI render和js执行是放在一个线程中，线程阻塞会导致界面无法更新渲染） 重新计算script运行时间，即重新判断”script is running too long”这个警告 改变了执行顺序 详细解释见下一篇文章《巧用setTimeout(func, 0)》。(2017-11-30注：本来想写的，偶然翻到一篇文章《这一次，彻底弄懂 JavaScript 执行机制》觉得已经写得很好了，就收藏啦(#^.^#)) 异步编程三种方法一：回调函数这是异步编程最基本的方法。假定有两个函数f1和f2，后者等待前者的执行结果。 12 f1(); f2(); 如果f1是一个很耗时的任务，可以考虑把f2写成f1的回调函数。 123456 function f1(callback)&#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000); &#125; 执行代码就变成下面这样： 1 f1(f2); 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行。回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。 二、事件监听另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。 1 f1.on('done', f2); 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写： 123456 function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger('done'); &#125;, 1000); &#125; f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 三、Promises对象Promise 是异步编程的一种解决方案，比传统的解决方案“回调函数”和“事件”——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。基本用法如下：12345678910111213const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123;// success&#125;, function(error) &#123; // failure&#125;); 下面列出异步操作失败、抓捕异常的另一种写法123456const promise = new Promise(function(resolve, reject) &#123; reject(new Error(&apos;test&apos;));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); 这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，可以实现许多强大的功能。比如，指定多个回调函数等等。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Q:为何img，input等内联元素可设置宽高？]]></title>
    <url>%2F2018%2F06%2F20%2FQ-%E4%B8%BA%E4%BD%95img%EF%BC%8Cinput%E7%AD%89%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E5%8F%AF%E8%AE%BE%E7%BD%AE%E5%AE%BD%E9%AB%98%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[简答：因为&lt;img&gt;、&lt;input&gt;属于替换元素，替换元素一般有内在尺寸和宽高比(auto时起作用)，所以具有width和height，可以设定。 细答：元素是文档结构的基础，在CSS中，每个元素生成了一个包含了元素内容的框（box，也译为“盒子”）。但是不同的元素显示的方式会有所不同，例如&lt;div&gt;和&lt;span&gt;就不同，而&lt;strong&gt;和 &lt;p&gt;也不一样。 1. 替换和不可替换元素从元素本身的特点来讲，可以分为替换和不可替换元素。 a) 替换元素替换元素 : 浏览器根据元素的标签和属性，来决定元素的具体显示内容。 例如浏览器会根据&lt;img&gt;标签的src属性的值来读取图片信息并显示出来;根据&lt;input&gt;标签的type属性来决定是显示输入框，还是单选按钮等。HTML中的&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;都是替换元素。这些元素往往没有实际的内容，即是一个空元素,浏览器会根据元素的标签类型和属性来显示这些元素。 b) 不可替换元素HTML 的大多数元素是不可替换元素，即其内容直接表现给用户端（例如浏览器）。 例如&lt;p&gt;段落的内容&lt;/p&gt;，段落&lt;p&gt;是一个不可替换元素，文字“段落的内容”全被显示。 2. 块级和行内元素除了可替换元素和不可替换元素的分类方式外，CSS2.1中元素还有另外的分类方式：块级元素（block-level）和行内元素（inline-level，也译作“内联”元素）。 a) 块级元素在视觉上被格式化为块的元素，最明显的特征就是默认在横向充满其父元素的内容区域，而且在其左右两边没有其他元素，即独占一行。 典型的块级元素有：&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;到&lt;h6&gt;，等等；通过CSS设定了浮动（float属性）以及设定显示（display）属性为“block”或“list-item”的元素都是块级元素。但是浮动元素比较特殊，由于浮动，其旁边可能会有其他元素的存在。而“list-item”（列表项&lt;li&gt;），会在其前面生成圆点符号，或者数字序号。 b) 行内元素行内元素不形成新内容块，即在其左右可以有其他元素。 例如&lt;a&gt;、&lt;span&gt;、&lt;strong&gt;等，都是典型的行内级元素。display属性等于“inline”的元素都是行内元素。 结语 几乎所有的替换元素都是行内元素，例如&lt;img&gt;、&lt;input&gt;等等。不过元素的类型也不是固定的，通过设定CSS 的display属性，可以使行内元素变为块级元素，也可以让块级元素变为行内元素。 替换元素一般有内在尺寸，所以具有width和height，可以设定。例如你不指定img的width和height时，就按其内在尺寸显示，也就是图片被保存的时候的宽度和高度。对于表单元素，浏览器也有默认的样式，包括宽度和高度。 补充知识点inline元素默认是基线对齐的 vertical-align=baseline]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script中defer和async的区别]]></title>
    <url>%2F2018%2F06%2F20%2Fscript%E4%B8%ADdefer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[定义 defer：此布尔属性被设置为向浏览器指示脚本在文档被解析后执行。async：设置此布尔属性，以指示浏览器如果可能的话，应异步执行脚本。 对于defer，我们可以认为是将外链的js放在了页面底部。js的加载不会阻塞页面的渲染和资源的加载。不过defer会按照原本的js的顺序执行，所以如果前后有依赖关系的js可以放心使用。 对于async，这个是html5中新增的属性，它的作用是能够异步的加载和执行脚本，不因为加载脚本而阻塞页面的加载。一旦加载到就会立刻执行在有async的情况下，js一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果js前后有依赖性，用async，就很有可能出错。 区别相同点： 加载文件时不阻塞页面渲染 对于inline的script（内联脚本）无效 使用这两个属性的脚本中不能调用document.write方法 有脚本的onload的事件回调 不同点： html的版本html4.0中定义了defer；html5.0中定义了async 浏览器兼容性 Feature Chrome Firefox (Gecko) Internet Explorer Opera Safari async attribute (Supported) 3.6 (1.9.2) 10 — (Supported) defer attribute (Supported) 3.5 (1.9.1) 4 — (Supported) 执行时刻每一个async属性的脚本都在它下载结束之后立刻执行，同时会在window的load事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况；每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行。 结语简单的来说，使用这两个属性会有三种可能的情况 如果async为true，那么脚本在下载完成后异步执行。 如果async为false，defer为true，那么脚本会在页面解析完毕之后执行。 如果async和defer都为false，那么脚本会在页面解析中，停止页面解析，立刻下载并且执行。 最后给一点个人的建议，无论使用defer还是async属性，都需要首先将页面中的js文件进行整理，哪些文件之间有依赖性，哪些文件可以延迟加载等等，做好js代码的合并和拆分，然后再根据页面需要使用这两个属性。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
